---
layout: page
title: FSOP
comments: true
tags: [fsop,file_streams,vtables]
---

So, here comes my favorite topic, File Stream Oriented Programming. This topic can be a little bit complex for people new to Heap Exploitation. This awesome technique was developed by [Angelboy](https://twitter.com/scwuaptx).

First thing's first, let's discuss about the `FILE` structure.

A stream is a logical entity that represents a file or device, that can accept input or output. `FILE` is nothing but a typedef'd strucutre present in the standard IO library. 

FILE is a structure for describing files in a standard IO library of a Linux system, called a file stream.

```c
struct _IO_FILE {

  int _flags;

#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */

  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */

  char* _IO_read_ptr;   /* Current read pointer */

  char* _IO_read_end;   /* End of get area. */

  char* _IO_read_base;  /* Start of putback + get area. */

  char* _IO_write_base; /* Start of put area. */

  char* _IO_write_ptr;  /* Current put pointer. */

  char* _IO_write_end;  /* End of put area. */

  char* _IO_buf_base;   /* Start of reserve area. */

  char* _IO_buf_end;    /* End of reserve area. */

  /* The following fields are used to support backing up and undo. */

  char *_IO_save_base; /* Pointer to start of non-current get area. */

  char *_IO_backup_base;  /* Pointer to first valid character of backup area */

  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;

#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */

  /* 1+column number of pbase(); 0 is unknown. */

  unsigned short _cur_column;

  signed char _vtable_offset;

  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;

#ifdef _IO_USE_OLD_IO_FILE

} FILE

```

A stream is linked to a file using an open operation and unlinked using a close operation.
`_flags` denotes the mode of a file stream such as read-only, open for reading and writing, etc.Thus, the stream buffer can be divided into three parts: read buffer (consists of `_IO_read_ptr` ,`_IO_read_end` and `_IO_read_base` ), write buffer (`_IO_write_ptr`, `_IO_write_end`, `_IO_write_base`) and reserve buffer(`_IO_buf_base`, `_IO_buf_end`). i/o operations . The pointers ending with `_base` point to the start of their respective buffers. The pointers ending with `_ptr` point to the current position in the buffer. Similarly, the pointers ending with `_end` point to the end of the buffer.


```c
extern _IO_FILE *_IO_stdin attribute_hidden;
extern _IO_FILE *_IO_stdout attribute_hidden;
extern _IO_FILE *_IO_stderr attribute_hidden;
```
Two FILE strucutres are connected to each other by the `_chain` field. Thus, the FILE structures form a linked list whose head is represented by the global variable `_IO_list_all`. `_fileno` is a file descriptor which is set by the `sys_open` syscall.


```c
/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

vtable is the virtual function table
```c
#define JUMP_FIELD(TYPE, NAME) TYPE NAME

struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```
The `_IO_FILE_plus` struct is an extension of the FILE structure. Standard input, output and error streams also use this structure.
```c
extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
```

## Virtual Functions
A virtual function is a member function of the base class that can be redefined in the derived classes. If we create a virtual function in the base class and it is being overridden in the derived class, we do not to redeclare it as virtual. It will automatically be considered as a virtual function. 

## vtables (Virtual Tables)
A vtable is a lookup table of functions used to resolve function calls in a dynamic manner. It stores function pointers of the virtual functions that can be called by objects of that class. Every class that uses virtual functions (or is derived from a class that uses virtual functions) is given its own vtable as a hidden data member (setup by the compiler at compile time). Every vtable has a vptr associated with it. A vptr points to a vtable, and is used to access functions present in the vtable. 
The addresses stored in the vtable or the vptr itself can be overwritten to perform code execution!!



Now, let's see the working of fopen, fread , fwrite and fclose as explained by [Angelboy](https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf). 

## fopen
Whenever fopen is called, the glibc allocates some memory for the `FILE` structure. 

```c
*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));

// Initializing the vtable

_IO_JUMPS (&new_f->fp) = &_IO_file_jumps;
_IO_file_init (&new_f->fp);


```

`_IO_link_in` is used to called to link the newly allocated `FILE` struct into the linked list of `FILE` structures

```c
void _IO_link_in (fp)     struct _IO_FILE_plus *fp;

{

    if ((fp->file._flags & _IO_LINKED) == 0)

    {

      fp->file._flags |= _IO_LINKED;

fp-&gt; file._chain = (_IO_FILE *) _IO_list_all;
      _IO_list_all = fp;

      ++_IO_list_all_stamp;

    }

}
```

After that, `_IO_file_fopen` is called
```
if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)

    return __fopen_maybe_mmap (&new_f->fp.file);

```

Summary: Whenever fopen is called, the glibc allocates some memory for the `FILE` structure. , some fields of the FILE structure are initialized followed by the insertion of `FILE` structure into the linked list of FILE stream after which a `sys_open` syscall is made.

## fread
If the file stream is not created, `_IO_file_doallocate` is used to allocate a new buffer for the file stream.
```c
int _IO_file_doallocate (_IO_FILE *fp)
{
  _IO_size_t size;
  char *p;
  struct stat64 st;

......................................
  p = malloc (size);
  if (__glibc_unlikely (p == NULL))
    return EOF;
  _IO_setb (fp, p, p + size, 1);
  return 1;
}
```
After that, `_IO_fread` is called which internally calls `_IO_sgetn` (present in the vtable as _IO_XSGETN). 
```c
size_t _IO_fread (void *buf, size_t size, size_t count, FILE *fp)
{
  size_t bytes_requested = size * count;
  size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

Summary:At the beginning of fread, if the stream is not created, `_IO_file_doallocate` is used to allocate a new buffer for the file stream. After that, data is read from the file into the stream buffer and then it is copied from the stream buffer to the destination.

## fwrite

`_IO_fwrite` calls `_IO_sputn` (present in the vtable as `_IO_XSPUTN`).
```c
_IO_size_t _IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t request = size * count;
  _IO_size_t written = 0;
  CHECK_FILE (fp, 0);
  if (request == 0)
    return 0;
  _IO_acquire_lock (fp);
  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)
    written = _IO_sputn (fp, (const char *) buf, request);
  _IO_release_lock (fp);
  /* We have written all of the input in case the return value indicates
     this or EOF is returned.  The latter is a special case where we
     simply did not manage to flush the buffer.  But the data is in the
     buffer and therefore written as far as fwrite is concerned.  */
  if (written == request || written == EOF)
    return count;
  else
    return written / size;
}

```
Further, `_IO_XSPUTN` calls  _IO_OVERFLOW  (or _IO_new_file_overflow)

```c
...
if (_IO_OVERFLOW (f, EOF) == EOF)
.....
```
Internally, _IO_OVERFLOW calls the system interface for write and checks if a flushes the stream.
```c
if (ch == EOF)

    return _IO_do_write (f, f->_IO_write_base,

             f->_IO_write_ptr - f->_IO_write_base);

  if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */

    if (_IO_do_flush (f) == EOF)

      return EOF;
```
Summary: If the stream buffer is not created, it allocates a stream buffer. After that, the user data is copied into the stream buffer and then data is written from the stream buffer to a file.

## fclose
`_IO_unlink_it` is called which unlinks a FILE structure from the linked list.

```c
if (fp->_IO_file_flags & _IO_IS_FILEBUF)

_IO_unlink_it ((struct _IO_FILE_plus *) fp);

```
After that, `_IO_file_close_it` is called which closes the file
```c
if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
```
Finally, `_IO_file_finish` is called which releases the file structure
```c
_IO_FINISH (fp);
```

Summary: It removes a FILE structure from the linked list of the file stream and then flushes the stream buffer, to make sure that everything is written to the file. Finally, it closes the file and releases the memory.


## Attacking the vtable

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

The vtable pointer can be used to gain control of execution flow in a program. [This post](https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/) provides a good demonstration of attack on vtables.

